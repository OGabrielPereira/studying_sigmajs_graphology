{"id":"node_modules/sigma/core/labels.js","dependencies":[{"name":"/home/ven/graphTest/package.json","includedInParent":true,"mtime":1664287371192},{"name":"/home/ven/graphTest/node_modules/sigma/package.json","includedInParent":true,"mtime":1664279401161}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.edgeLabelsToDisplayFromNodes = exports.LabelGrid = void 0;\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /** @class */ (function () {\n    function LabelCandidate(key, size) {\n        this.key = key;\n        this.size = size;\n    }\n    LabelCandidate.compare = function (first, second) {\n        // First we compare by size\n        if (first.size > second.size)\n            return -1;\n        if (first.size < second.size)\n            return 1;\n        // Then since no two nodes can have the same key, we use it to\n        // deterministically tie-break by key\n        if (first.key > second.key)\n            return 1;\n        // NOTE: this comparator cannot return 0\n        return -1;\n    };\n    return LabelCandidate;\n}());\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /** @class */ (function () {\n    function LabelGrid() {\n        this.width = 0;\n        this.height = 0;\n        this.cellSize = 0;\n        this.columns = 0;\n        this.rows = 0;\n        this.cells = {};\n    }\n    LabelGrid.prototype.resizeAndClear = function (dimensions, cellSize) {\n        this.width = dimensions.width;\n        this.height = dimensions.height;\n        this.cellSize = cellSize;\n        this.columns = Math.ceil(dimensions.width / cellSize);\n        this.rows = Math.ceil(dimensions.height / cellSize);\n        this.cells = {};\n    };\n    LabelGrid.prototype.getIndex = function (pos) {\n        var xIndex = Math.floor(pos.x / this.cellSize);\n        var yIndex = Math.floor(pos.y / this.cellSize);\n        return yIndex * this.columns + xIndex;\n    };\n    LabelGrid.prototype.add = function (key, size, pos) {\n        var candidate = new LabelCandidate(key, size);\n        var index = this.getIndex(pos);\n        var cell = this.cells[index];\n        if (!cell) {\n            cell = [];\n            this.cells[index] = cell;\n        }\n        cell.push(candidate);\n    };\n    LabelGrid.prototype.organize = function () {\n        for (var k in this.cells) {\n            var cell = this.cells[k];\n            cell.sort(LabelCandidate.compare);\n        }\n    };\n    LabelGrid.prototype.getLabelsToDisplay = function (ratio, density) {\n        // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n        // TODO: adjust threshold lower, but increase cells a bit?\n        // TODO: hunt for geom issue in disguise\n        // TODO: memoize while ratio does not move. method to force recompute\n        var cellArea = this.cellSize * this.cellSize;\n        var scaledCellArea = cellArea / ratio / ratio;\n        var scaledDensity = (scaledCellArea * density) / cellArea;\n        var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n        var labels = [];\n        for (var k in this.cells) {\n            var cell = this.cells[k];\n            for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n                labels.push(cell[i].key);\n            }\n        }\n        return labels;\n    };\n    return LabelGrid;\n}());\nexports.LabelGrid = LabelGrid;\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n    var graph = params.graph, hoveredNode = params.hoveredNode, highlightedNodes = params.highlightedNodes, displayedNodeLabels = params.displayedNodeLabels;\n    var worthyEdges = [];\n    // TODO: the code below can be optimized using #.forEach and batching the code per adj\n    // We should display an edge's label if:\n    //   - Any of its extremities is highlighted or hovered\n    //   - Both of its extremities has its label shown\n    graph.forEachEdge(function (edge, _, source, target) {\n        if (source === hoveredNode ||\n            target === hoveredNode ||\n            highlightedNodes.has(source) ||\n            highlightedNodes.has(target) ||\n            (displayedNodeLabels.has(source) && displayedNodeLabels.has(target))) {\n            worthyEdges.push(edge);\n        }\n    });\n    return worthyEdges;\n}\nexports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;\n"},"sourceMaps":{"js":{"mappings":[{"source":"node_modules/sigma/core/labels.js","original":{"line":1,"column":0},"generated":{"line":1,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":2,"column":0},"generated":{"line":2,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":3,"column":0},"generated":{"line":3,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":4,"column":0},"generated":{"line":4,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":5,"column":0},"generated":{"line":5,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":6,"column":0},"generated":{"line":6,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":7,"column":0},"generated":{"line":7,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":8,"column":0},"generated":{"line":8,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":9,"column":0},"generated":{"line":9,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":10,"column":0},"generated":{"line":10,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":11,"column":0},"generated":{"line":11,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":12,"column":0},"generated":{"line":12,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":13,"column":0},"generated":{"line":13,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":14,"column":0},"generated":{"line":14,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":15,"column":0},"generated":{"line":15,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":16,"column":0},"generated":{"line":16,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":17,"column":0},"generated":{"line":17,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":18,"column":0},"generated":{"line":18,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":19,"column":0},"generated":{"line":19,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":20,"column":0},"generated":{"line":20,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":21,"column":0},"generated":{"line":21,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":22,"column":0},"generated":{"line":22,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":23,"column":0},"generated":{"line":23,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":24,"column":0},"generated":{"line":24,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":25,"column":0},"generated":{"line":25,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":26,"column":0},"generated":{"line":26,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":27,"column":0},"generated":{"line":27,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":28,"column":0},"generated":{"line":28,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":29,"column":0},"generated":{"line":29,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":30,"column":0},"generated":{"line":30,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":31,"column":0},"generated":{"line":31,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":32,"column":0},"generated":{"line":32,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":33,"column":0},"generated":{"line":33,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":34,"column":0},"generated":{"line":34,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":35,"column":0},"generated":{"line":35,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":36,"column":0},"generated":{"line":36,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":37,"column":0},"generated":{"line":37,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":38,"column":0},"generated":{"line":38,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":39,"column":0},"generated":{"line":39,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":40,"column":0},"generated":{"line":40,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":41,"column":0},"generated":{"line":41,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":42,"column":0},"generated":{"line":42,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":43,"column":0},"generated":{"line":43,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":44,"column":0},"generated":{"line":44,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":45,"column":0},"generated":{"line":45,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":46,"column":0},"generated":{"line":46,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":47,"column":0},"generated":{"line":47,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":48,"column":0},"generated":{"line":48,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":49,"column":0},"generated":{"line":49,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":50,"column":0},"generated":{"line":50,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":51,"column":0},"generated":{"line":51,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":52,"column":0},"generated":{"line":52,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":53,"column":0},"generated":{"line":53,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":54,"column":0},"generated":{"line":54,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":55,"column":0},"generated":{"line":55,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":56,"column":0},"generated":{"line":56,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":57,"column":0},"generated":{"line":57,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":58,"column":0},"generated":{"line":58,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":59,"column":0},"generated":{"line":59,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":60,"column":0},"generated":{"line":60,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":61,"column":0},"generated":{"line":61,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":62,"column":0},"generated":{"line":62,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":63,"column":0},"generated":{"line":63,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":64,"column":0},"generated":{"line":64,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":65,"column":0},"generated":{"line":65,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":66,"column":0},"generated":{"line":66,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":67,"column":0},"generated":{"line":67,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":68,"column":0},"generated":{"line":68,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":69,"column":0},"generated":{"line":69,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":70,"column":0},"generated":{"line":70,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":71,"column":0},"generated":{"line":71,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":72,"column":0},"generated":{"line":72,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":73,"column":0},"generated":{"line":73,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":74,"column":0},"generated":{"line":74,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":75,"column":0},"generated":{"line":75,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":76,"column":0},"generated":{"line":76,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":77,"column":0},"generated":{"line":77,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":78,"column":0},"generated":{"line":78,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":79,"column":0},"generated":{"line":79,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":80,"column":0},"generated":{"line":80,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":81,"column":0},"generated":{"line":81,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":82,"column":0},"generated":{"line":82,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":83,"column":0},"generated":{"line":83,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":84,"column":0},"generated":{"line":84,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":85,"column":0},"generated":{"line":85,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":86,"column":0},"generated":{"line":86,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":87,"column":0},"generated":{"line":87,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":88,"column":0},"generated":{"line":88,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":89,"column":0},"generated":{"line":89,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":90,"column":0},"generated":{"line":90,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":91,"column":0},"generated":{"line":91,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":92,"column":0},"generated":{"line":92,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":93,"column":0},"generated":{"line":93,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":94,"column":0},"generated":{"line":94,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":95,"column":0},"generated":{"line":95,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":96,"column":0},"generated":{"line":96,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":97,"column":0},"generated":{"line":97,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":98,"column":0},"generated":{"line":98,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":99,"column":0},"generated":{"line":99,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":100,"column":0},"generated":{"line":100,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":101,"column":0},"generated":{"line":101,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":102,"column":0},"generated":{"line":102,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":103,"column":0},"generated":{"line":103,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":104,"column":0},"generated":{"line":104,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":105,"column":0},"generated":{"line":105,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":106,"column":0},"generated":{"line":106,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":107,"column":0},"generated":{"line":107,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":108,"column":0},"generated":{"line":108,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":109,"column":0},"generated":{"line":109,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":110,"column":0},"generated":{"line":110,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":111,"column":0},"generated":{"line":111,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":112,"column":0},"generated":{"line":112,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":113,"column":0},"generated":{"line":113,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":114,"column":0},"generated":{"line":114,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":115,"column":0},"generated":{"line":115,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":116,"column":0},"generated":{"line":116,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":117,"column":0},"generated":{"line":117,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":118,"column":0},"generated":{"line":118,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":119,"column":0},"generated":{"line":119,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":120,"column":0},"generated":{"line":120,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":121,"column":0},"generated":{"line":121,"column":0}},{"source":"node_modules/sigma/core/labels.js","original":{"line":122,"column":0},"generated":{"line":122,"column":0}}],"sources":{"node_modules/sigma/core/labels.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.edgeLabelsToDisplayFromNodes = exports.LabelGrid = void 0;\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /** @class */ (function () {\n    function LabelCandidate(key, size) {\n        this.key = key;\n        this.size = size;\n    }\n    LabelCandidate.compare = function (first, second) {\n        // First we compare by size\n        if (first.size > second.size)\n            return -1;\n        if (first.size < second.size)\n            return 1;\n        // Then since no two nodes can have the same key, we use it to\n        // deterministically tie-break by key\n        if (first.key > second.key)\n            return 1;\n        // NOTE: this comparator cannot return 0\n        return -1;\n    };\n    return LabelCandidate;\n}());\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /** @class */ (function () {\n    function LabelGrid() {\n        this.width = 0;\n        this.height = 0;\n        this.cellSize = 0;\n        this.columns = 0;\n        this.rows = 0;\n        this.cells = {};\n    }\n    LabelGrid.prototype.resizeAndClear = function (dimensions, cellSize) {\n        this.width = dimensions.width;\n        this.height = dimensions.height;\n        this.cellSize = cellSize;\n        this.columns = Math.ceil(dimensions.width / cellSize);\n        this.rows = Math.ceil(dimensions.height / cellSize);\n        this.cells = {};\n    };\n    LabelGrid.prototype.getIndex = function (pos) {\n        var xIndex = Math.floor(pos.x / this.cellSize);\n        var yIndex = Math.floor(pos.y / this.cellSize);\n        return yIndex * this.columns + xIndex;\n    };\n    LabelGrid.prototype.add = function (key, size, pos) {\n        var candidate = new LabelCandidate(key, size);\n        var index = this.getIndex(pos);\n        var cell = this.cells[index];\n        if (!cell) {\n            cell = [];\n            this.cells[index] = cell;\n        }\n        cell.push(candidate);\n    };\n    LabelGrid.prototype.organize = function () {\n        for (var k in this.cells) {\n            var cell = this.cells[k];\n            cell.sort(LabelCandidate.compare);\n        }\n    };\n    LabelGrid.prototype.getLabelsToDisplay = function (ratio, density) {\n        // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n        // TODO: adjust threshold lower, but increase cells a bit?\n        // TODO: hunt for geom issue in disguise\n        // TODO: memoize while ratio does not move. method to force recompute\n        var cellArea = this.cellSize * this.cellSize;\n        var scaledCellArea = cellArea / ratio / ratio;\n        var scaledDensity = (scaledCellArea * density) / cellArea;\n        var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n        var labels = [];\n        for (var k in this.cells) {\n            var cell = this.cells[k];\n            for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n                labels.push(cell[i].key);\n            }\n        }\n        return labels;\n    };\n    return LabelGrid;\n}());\nexports.LabelGrid = LabelGrid;\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n    var graph = params.graph, hoveredNode = params.hoveredNode, highlightedNodes = params.highlightedNodes, displayedNodeLabels = params.displayedNodeLabels;\n    var worthyEdges = [];\n    // TODO: the code below can be optimized using #.forEach and batching the code per adj\n    // We should display an edge's label if:\n    //   - Any of its extremities is highlighted or hovered\n    //   - Both of its extremities has its label shown\n    graph.forEachEdge(function (edge, _, source, target) {\n        if (source === hoveredNode ||\n            target === hoveredNode ||\n            highlightedNodes.has(source) ||\n            highlightedNodes.has(target) ||\n            (displayedNodeLabels.has(source) && displayedNodeLabels.has(target))) {\n            worthyEdges.push(edge);\n        }\n    });\n    return worthyEdges;\n}\nexports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;\n"},"lineCount":122}},"error":null,"hash":"5a796a6d651de6b0a547c68aca4b3ed2","cacheData":{"env":{}}}